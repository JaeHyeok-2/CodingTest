# n개의 동전으로 m 원을 만들때 최소한의 동전개수로 만들어보자!
n, m = map(int, input().split())
array = [] # 배열안에는 동전들이 들어가있겠지? ex) n = 3 m =7 이고
for i in range(n):
    array.append(int(input())) # array에 2,3,5원의 동전들이 들어가본다 치자

d = [10001] * (m + 1) # d 의 해당값  = 해당 배열의 번호 = 금액 / 해당 배열의 값 =  금액을 만들기 위한 최소 동전의 개수

d[0] = 0  # 0원은 그냥 아무것도 안해도 0원이니까 0개
for i in range(n):
    for j in range(array[i], m + 1): # 2원부터 순회 -> 3원짜리 순회 -> 5원짜리 순회 코드
        if d[j - array[i]] != 10001:
            d[j] = min(d[j], d[j - array[i]] + 1) #
    """
    위의 코드 설명
    1) n = 3 이니까 i = [0,1,2]를 순회
    2) j 는 i = 0 일때 -> (array[0] = 2 ,m +1 = 8) 이므로 (2,8) 
            i = 1 일때 -> (3,8)
            i = 2 일때 -> (5,8) 
    ----------------
    예시) 
    
    예를들어 6원을 만드는 최소 과정을 살펴보면
    현재, d[2] =10001 로 되어있고, d[2] 는 d[0] + 1 이잖아? 
    d[2] = 2원짜리동전 1개 => min(10001,d[0]+1)
    d[4] = d[2]에서 2원짜리 동전1개만 더하면되겠지 -> min(d[4],d[2]+1)중 최솟값
    d[6] = min(d[6],d[4]+1) --> 3개 인데
    
    하지만,
    -----------
    2원이 모두 순회를 끝내고 3원차례
    d[3] = min(d[3] ,d[0]+1) <----- 0원+ 3원짜리동전1개값 = 1 /
    d[6] = min[d[6], d[3]+1) <-------- 2원짜리가 d[6] =3 을 구해놨지만 , d[3]+1 = 2이므로 d[6] =2 로 갱신
    
    """

if d[m] == 10001:
    print(-1)
else:
    print(d[m])